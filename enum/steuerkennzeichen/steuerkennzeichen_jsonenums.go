// Code generated by jsonenums --type Steuerkennzeichen; DO NOT EDIT.

package steuerkennzeichen

import (
	"encoding/json"
	"fmt"
)

var (
	_SteuerkennzeichenNameToValue = map[string]Steuerkennzeichen{
		"Ust0":  Ust0,
		"Ust19": Ust19,
		"Ust7":  Ust7,
		"Vst0":  Vst0,
		"Vst19": Vst19,
		"Vst7":  Vst7,
		"RCV":   RCV,
	}

	_SteuerkennzeichenValueToName = map[Steuerkennzeichen]string{
		Ust0:  "Ust0",
		Ust19: "Ust19",
		Ust7:  "Ust7",
		Vst0:  "Vst0",
		Vst19: "Vst19",
		Vst7:  "Vst7",
		RCV:   "RCV",
	}
)

func init() {
	var v Steuerkennzeichen
	if _, ok := interface{}(v).(fmt.Stringer); ok {
		_SteuerkennzeichenNameToValue = map[string]Steuerkennzeichen{
			interface{}(Ust0).(fmt.Stringer).String():  Ust0,
			interface{}(Ust19).(fmt.Stringer).String(): Ust19,
			interface{}(Ust7).(fmt.Stringer).String():  Ust7,
			interface{}(Vst0).(fmt.Stringer).String():  Vst0,
			interface{}(Vst19).(fmt.Stringer).String(): Vst19,
			interface{}(Vst7).(fmt.Stringer).String():  Vst7,
			interface{}(RCV).(fmt.Stringer).String():   RCV,
		}
	}
}

// MarshalJSON is generated so Steuerkennzeichen satisfies json.Marshaler.
func (r Steuerkennzeichen) MarshalJSON() ([]byte, error) {
	if s, ok := interface{}(r).(fmt.Stringer); ok {
		return json.Marshal(s.String())
	}
	s, ok := _SteuerkennzeichenValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid Steuerkennzeichen: %d", r)
	}
	return json.Marshal(s)
}

// UnmarshalJSON is generated so Steuerkennzeichen satisfies json.Unmarshaler.
func (r *Steuerkennzeichen) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Steuerkennzeichen should be a string, got %s", data)
	}
	v, ok := _SteuerkennzeichenNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid Steuerkennzeichen %q", s)
	}
	*r = v
	return nil
}

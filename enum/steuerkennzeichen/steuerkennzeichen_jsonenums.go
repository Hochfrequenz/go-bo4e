// Code generated by jsonenums --type Steuerkennzeichen; DO NOT EDIT.

package steuerkennzeichen

import (
	"encoding/json"
	"fmt"
)

var (
	_SteuerkennzeichenNameToValue = map[string]Steuerkennzeichen{
		"UST0":  UST0,
		"UST19": UST19,
		"UST7":  UST7,
		"VST0":  VST0,
		"VST19": VST19,
		"VST7":  VST7,
		"RCV":   RCV,
	}

	_SteuerkennzeichenValueToName = map[Steuerkennzeichen]string{
		UST0:  "UST0",
		UST19: "UST19",
		UST7:  "UST7",
		VST0:  "VST0",
		VST19: "VST19",
		VST7:  "VST7",
		RCV:   "RCV",
	}
)

func init() {
	var v Steuerkennzeichen
	if _, ok := interface{}(v).(fmt.Stringer); ok {
		_SteuerkennzeichenNameToValue = map[string]Steuerkennzeichen{
			interface{}(UST0).(fmt.Stringer).String():  UST0,
			interface{}(UST19).(fmt.Stringer).String(): UST19,
			interface{}(UST7).(fmt.Stringer).String():  UST7,
			interface{}(VST0).(fmt.Stringer).String():  VST0,
			interface{}(VST19).(fmt.Stringer).String(): VST19,
			interface{}(VST7).(fmt.Stringer).String():  VST7,
			interface{}(RCV).(fmt.Stringer).String():   RCV,
		}
	}
}

// MarshalJSON is generated so Steuerkennzeichen satisfies json.Marshaler.
func (r Steuerkennzeichen) MarshalJSON() ([]byte, error) {
	if s, ok := interface{}(r).(fmt.Stringer); ok {
		return json.Marshal(s.String())
	}
	s, ok := _SteuerkennzeichenValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid Steuerkennzeichen: %d", r)
	}
	return json.Marshal(s)
}

// UnmarshalJSON is generated so Steuerkennzeichen satisfies json.Unmarshaler.
func (r *Steuerkennzeichen) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Steuerkennzeichen should be a string, got %s", data)
	}
	v, ok := _SteuerkennzeichenNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid Steuerkennzeichen %q", s)
	}
	*r = v
	return nil
}

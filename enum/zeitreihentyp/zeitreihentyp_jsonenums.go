// Code generated by jsonenums --type Zeitreihentyp; DO NOT EDIT.

package zeitreihentyp

import (
	"encoding/json"
	"fmt"
)

var (
	_ZeitreihentypNameToValue = map[string]Zeitreihentyp{
		"EGS":     EGS,
		"LGS":     LGS,
		"NZR":     NZR,
		"SES":     SES,
		"SLS":     SLS,
		"TES":     TES,
		"TLS":     TLS,
		"SLS_TLS": SLS_TLS,
		"SES_TES": SES_TES,
		"AUS":     AUS,
		"BAS":     BAS,
		"DBA":     DBA,
		"DZR":     DZR,
		"DZÜ":     DZÜ,
		"FPE":     FPE,
		"FPI":     FPI,
		"SRE":     SRE,
		"SRI":     SRI,
		"VZR":     VZR,
	}

	_ZeitreihentypValueToName = map[Zeitreihentyp]string{
		EGS:     "EGS",
		LGS:     "LGS",
		NZR:     "NZR",
		SES:     "SES",
		SLS:     "SLS",
		TES:     "TES",
		TLS:     "TLS",
		SLS_TLS: "SLS_TLS",
		SES_TES: "SES_TES",
		AUS:     "AUS",
		BAS:     "BAS",
		DBA:     "DBA",
		DZR:     "DZR",
		DZÜ:     "DZÜ",
		FPE:     "FPE",
		FPI:     "FPI",
		SRE:     "SRE",
		SRI:     "SRI",
		VZR:     "VZR",
	}
)

func init() {
	var v Zeitreihentyp
	if _, ok := interface{}(v).(fmt.Stringer); ok {
		_ZeitreihentypNameToValue = map[string]Zeitreihentyp{
			interface{}(EGS).(fmt.Stringer).String():     EGS,
			interface{}(LGS).(fmt.Stringer).String():     LGS,
			interface{}(NZR).(fmt.Stringer).String():     NZR,
			interface{}(SES).(fmt.Stringer).String():     SES,
			interface{}(SLS).(fmt.Stringer).String():     SLS,
			interface{}(TES).(fmt.Stringer).String():     TES,
			interface{}(TLS).(fmt.Stringer).String():     TLS,
			interface{}(SLS_TLS).(fmt.Stringer).String(): SLS_TLS,
			interface{}(SES_TES).(fmt.Stringer).String(): SES_TES,
			interface{}(AUS).(fmt.Stringer).String():     AUS,
			interface{}(BAS).(fmt.Stringer).String():     BAS,
			interface{}(DBA).(fmt.Stringer).String():     DBA,
			interface{}(DZR).(fmt.Stringer).String():     DZR,
			interface{}(DZÜ).(fmt.Stringer).String():     DZÜ,
			interface{}(FPE).(fmt.Stringer).String():     FPE,
			interface{}(FPI).(fmt.Stringer).String():     FPI,
			interface{}(SRE).(fmt.Stringer).String():     SRE,
			interface{}(SRI).(fmt.Stringer).String():     SRI,
			interface{}(VZR).(fmt.Stringer).String():     VZR,
		}
	}
}

// MarshalJSON is generated so Zeitreihentyp satisfies json.Marshaler.
func (r Zeitreihentyp) MarshalJSON() ([]byte, error) {
	if s, ok := interface{}(r).(fmt.Stringer); ok {
		return json.Marshal(s.String())
	}
	s, ok := _ZeitreihentypValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid Zeitreihentyp: %d", r)
	}
	return json.Marshal(s)
}

// UnmarshalJSON is generated so Zeitreihentyp satisfies json.Unmarshaler.
func (r *Zeitreihentyp) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Zeitreihentyp should be a string, got %s", data)
	}
	v, ok := _ZeitreihentypNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid Zeitreihentyp %q", s)
	}
	*r = v
	return nil
}

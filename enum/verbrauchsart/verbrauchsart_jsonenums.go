// Code generated by jsonenums --type Verbrauchsart; DO NOT EDIT.

package verbrauchsart

import (
	"encoding/json"
	"fmt"
)

var (
	_VerbrauchsartNameToValue = map[string]Verbrauchsart{
		"KL":   KL,
		"KLW":  KLW,
		"KLWS": KLWS,
		"W":    W,
		"WS":   WS,
		"WK":   WK,
		"EM":   EM,
		"STRB": STRB,
		"STW":  STW,
	}

	_VerbrauchsartValueToName = map[Verbrauchsart]string{
		KL:   "KL",
		KLW:  "KLW",
		KLWS: "KLWS",
		W:    "W",
		WS:   "WS",
		WK:   "WK",
		EM:   "EM",
		STRB: "STRB",
		STW:  "STW",
	}
)

func init() {
	var v Verbrauchsart
	if _, ok := interface{}(v).(fmt.Stringer); ok {
		_VerbrauchsartNameToValue = map[string]Verbrauchsart{
			interface{}(KL).(fmt.Stringer).String():   KL,
			interface{}(KLW).(fmt.Stringer).String():  KLW,
			interface{}(KLWS).(fmt.Stringer).String(): KLWS,
			interface{}(W).(fmt.Stringer).String():    W,
			interface{}(WS).(fmt.Stringer).String():   WS,
			interface{}(WK).(fmt.Stringer).String():   WK,
			interface{}(EM).(fmt.Stringer).String():   EM,
			interface{}(STRB).(fmt.Stringer).String(): STRB,
			interface{}(STW).(fmt.Stringer).String():  STW,
		}
	}
}

// MarshalJSON is generated so Verbrauchsart satisfies json.Marshaler.
func (r Verbrauchsart) MarshalJSON() ([]byte, error) {
	if s, ok := interface{}(r).(fmt.Stringer); ok {
		return json.Marshal(s.String())
	}
	s, ok := _VerbrauchsartValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid Verbrauchsart: %d", r)
	}
	return json.Marshal(s)
}

// UnmarshalJSON is generated so Verbrauchsart satisfies json.Unmarshaler.
func (r *Verbrauchsart) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Verbrauchsart should be a string, got %s", data)
	}
	v, ok := _VerbrauchsartNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid Verbrauchsart %q", s)
	}
	*r = v
	return nil
}

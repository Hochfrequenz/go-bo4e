// Code generated by jsonenums --type Messpreistyp; DO NOT EDIT.

package messpreistyp

import (
	"encoding/json"
	"fmt"
)

var (
	_MesspreistypNameToValue = map[string]Messpreistyp{
		"MESSPREIS_G4":                 MESSPREIS_G4,
		"MESSPREIS_G6":                 MESSPREIS_G6,
		"MESSPREIS_G10":                MESSPREIS_G10,
		"MESSPREIS_G16":                MESSPREIS_G16,
		"MESSPREIS_G25":                MESSPREIS_G25,
		"MESSPREIS_G40":                MESSPREIS_G40,
		"ELEKTRONISCHER_AUFSATZ":       ELEKTRONISCHER_AUFSATZ,
		"SMART_METER_MESSPREIS_G2_5":   SMART_METER_MESSPREIS_G2_5,
		"SMART_METER_MESSPREIS_G4":     SMART_METER_MESSPREIS_G4,
		"SMART_METER_MESSPREIS_G6":     SMART_METER_MESSPREIS_G6,
		"SMART_METER_MESSPREIS_G10":    SMART_METER_MESSPREIS_G10,
		"SMART_METER_MESSPREIS_G16":    SMART_METER_MESSPREIS_G16,
		"SMART_METER_MESSPREIS_G25":    SMART_METER_MESSPREIS_G25,
		"SMART_METER_MESSPREIS_G40":    SMART_METER_MESSPREIS_G40,
		"VERRECHNUNGSPREIS_ET_WECHSEL": VERRECHNUNGSPREIS_ET_WECHSEL,
		"VERRECHNUNGSPREIS_ET_DREH":    VERRECHNUNGSPREIS_ET_DREH,
		"VERRECHNUNGSPREIS_ZT_WECHSEL": VERRECHNUNGSPREIS_ZT_WECHSEL,
		"VERRECHNUNGSPREIS_ZT_DREH":    VERRECHNUNGSPREIS_ZT_DREH,
		"VERRECHNUNGSPREIS_L_ET":       VERRECHNUNGSPREIS_L_ET,
		"VERRECHNUNGSPREIS_L_ZT":       VERRECHNUNGSPREIS_L_ZT,
		"VERRECHNUNGSPREIS_SM":         VERRECHNUNGSPREIS_SM,
		"AUFSCHLAG_WANDLER":            AUFSCHLAG_WANDLER,
		"AUFSCHLAG_TARIFSCHALTUNG":     AUFSCHLAG_TARIFSCHALTUNG,
	}

	_MesspreistypValueToName = map[Messpreistyp]string{
		MESSPREIS_G4:                 "MESSPREIS_G4",
		MESSPREIS_G6:                 "MESSPREIS_G6",
		MESSPREIS_G10:                "MESSPREIS_G10",
		MESSPREIS_G16:                "MESSPREIS_G16",
		MESSPREIS_G25:                "MESSPREIS_G25",
		MESSPREIS_G40:                "MESSPREIS_G40",
		ELEKTRONISCHER_AUFSATZ:       "ELEKTRONISCHER_AUFSATZ",
		SMART_METER_MESSPREIS_G2_5:   "SMART_METER_MESSPREIS_G2_5",
		SMART_METER_MESSPREIS_G4:     "SMART_METER_MESSPREIS_G4",
		SMART_METER_MESSPREIS_G6:     "SMART_METER_MESSPREIS_G6",
		SMART_METER_MESSPREIS_G10:    "SMART_METER_MESSPREIS_G10",
		SMART_METER_MESSPREIS_G16:    "SMART_METER_MESSPREIS_G16",
		SMART_METER_MESSPREIS_G25:    "SMART_METER_MESSPREIS_G25",
		SMART_METER_MESSPREIS_G40:    "SMART_METER_MESSPREIS_G40",
		VERRECHNUNGSPREIS_ET_WECHSEL: "VERRECHNUNGSPREIS_ET_WECHSEL",
		VERRECHNUNGSPREIS_ET_DREH:    "VERRECHNUNGSPREIS_ET_DREH",
		VERRECHNUNGSPREIS_ZT_WECHSEL: "VERRECHNUNGSPREIS_ZT_WECHSEL",
		VERRECHNUNGSPREIS_ZT_DREH:    "VERRECHNUNGSPREIS_ZT_DREH",
		VERRECHNUNGSPREIS_L_ET:       "VERRECHNUNGSPREIS_L_ET",
		VERRECHNUNGSPREIS_L_ZT:       "VERRECHNUNGSPREIS_L_ZT",
		VERRECHNUNGSPREIS_SM:         "VERRECHNUNGSPREIS_SM",
		AUFSCHLAG_WANDLER:            "AUFSCHLAG_WANDLER",
		AUFSCHLAG_TARIFSCHALTUNG:     "AUFSCHLAG_TARIFSCHALTUNG",
	}
)

func init() {
	var v Messpreistyp
	if _, ok := interface{}(v).(fmt.Stringer); ok {
		_MesspreistypNameToValue = map[string]Messpreistyp{
			interface{}(MESSPREIS_G4).(fmt.Stringer).String():                 MESSPREIS_G4,
			interface{}(MESSPREIS_G6).(fmt.Stringer).String():                 MESSPREIS_G6,
			interface{}(MESSPREIS_G10).(fmt.Stringer).String():                MESSPREIS_G10,
			interface{}(MESSPREIS_G16).(fmt.Stringer).String():                MESSPREIS_G16,
			interface{}(MESSPREIS_G25).(fmt.Stringer).String():                MESSPREIS_G25,
			interface{}(MESSPREIS_G40).(fmt.Stringer).String():                MESSPREIS_G40,
			interface{}(ELEKTRONISCHER_AUFSATZ).(fmt.Stringer).String():       ELEKTRONISCHER_AUFSATZ,
			interface{}(SMART_METER_MESSPREIS_G2_5).(fmt.Stringer).String():   SMART_METER_MESSPREIS_G2_5,
			interface{}(SMART_METER_MESSPREIS_G4).(fmt.Stringer).String():     SMART_METER_MESSPREIS_G4,
			interface{}(SMART_METER_MESSPREIS_G6).(fmt.Stringer).String():     SMART_METER_MESSPREIS_G6,
			interface{}(SMART_METER_MESSPREIS_G10).(fmt.Stringer).String():    SMART_METER_MESSPREIS_G10,
			interface{}(SMART_METER_MESSPREIS_G16).(fmt.Stringer).String():    SMART_METER_MESSPREIS_G16,
			interface{}(SMART_METER_MESSPREIS_G25).(fmt.Stringer).String():    SMART_METER_MESSPREIS_G25,
			interface{}(SMART_METER_MESSPREIS_G40).(fmt.Stringer).String():    SMART_METER_MESSPREIS_G40,
			interface{}(VERRECHNUNGSPREIS_ET_WECHSEL).(fmt.Stringer).String(): VERRECHNUNGSPREIS_ET_WECHSEL,
			interface{}(VERRECHNUNGSPREIS_ET_DREH).(fmt.Stringer).String():    VERRECHNUNGSPREIS_ET_DREH,
			interface{}(VERRECHNUNGSPREIS_ZT_WECHSEL).(fmt.Stringer).String(): VERRECHNUNGSPREIS_ZT_WECHSEL,
			interface{}(VERRECHNUNGSPREIS_ZT_DREH).(fmt.Stringer).String():    VERRECHNUNGSPREIS_ZT_DREH,
			interface{}(VERRECHNUNGSPREIS_L_ET).(fmt.Stringer).String():       VERRECHNUNGSPREIS_L_ET,
			interface{}(VERRECHNUNGSPREIS_L_ZT).(fmt.Stringer).String():       VERRECHNUNGSPREIS_L_ZT,
			interface{}(VERRECHNUNGSPREIS_SM).(fmt.Stringer).String():         VERRECHNUNGSPREIS_SM,
			interface{}(AUFSCHLAG_WANDLER).(fmt.Stringer).String():            AUFSCHLAG_WANDLER,
			interface{}(AUFSCHLAG_TARIFSCHALTUNG).(fmt.Stringer).String():     AUFSCHLAG_TARIFSCHALTUNG,
		}
	}
}

// MarshalJSON is generated so Messpreistyp satisfies json.Marshaler.
func (r Messpreistyp) MarshalJSON() ([]byte, error) {
	if s, ok := interface{}(r).(fmt.Stringer); ok {
		return json.Marshal(s.String())
	}
	s, ok := _MesspreistypValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid Messpreistyp: %d", r)
	}
	return json.Marshal(s)
}

// UnmarshalJSON is generated so Messpreistyp satisfies json.Unmarshaler.
func (r *Messpreistyp) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Messpreistyp should be a string, got %s", data)
	}
	v, ok := _MesspreistypNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid Messpreistyp %q", s)
	}
	*r = v
	return nil
}

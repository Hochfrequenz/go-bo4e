// Code generated by jsonenums --type Kundengruppe; DO NOT EDIT.

package kundengruppe

import (
	"encoding/json"
	"fmt"
)

var (
	_KundengruppeNameToValue = map[string]Kundengruppe{
		"RLM":       RLM,
		"SLP_S_G0":  SLP_S_G0,
		"SLP_S_G1":  SLP_S_G1,
		"SLP_S_G2":  SLP_S_G2,
		"SLP_S_G3":  SLP_S_G3,
		"SLP_S_G4":  SLP_S_G4,
		"SLP_S_G5":  SLP_S_G5,
		"SLP_S_G6":  SLP_S_G6,
		"SLP_S_G7":  SLP_S_G7,
		"SLP_S_L0":  SLP_S_L0,
		"SLP_S_L1":  SLP_S_L1,
		"SLP_S_L2":  SLP_S_L2,
		"SLP_S_H0":  SLP_S_H0,
		"SLP_S_SB":  SLP_S_SB,
		"SLP_S_HZ":  SLP_S_HZ,
		"SLP_S_WP":  SLP_S_WP,
		"SLP_G_GKO": SLP_G_GKO,
		"SLP_G_GHA": SLP_G_GHA,
		"SLP_G_GMK": SLP_G_GMK,
		"SLP_G_GBD": SLP_G_GBD,
		"SLP_G_GGA": SLP_G_GGA,
		"SLP_G_GBH": SLP_G_GBH,
		"SLP_G_GBA": SLP_G_GBA,
		"SLP_G_GWA": SLP_G_GWA,
		"SLP_G_GGB": SLP_G_GGB,
		"SLP_G_GPD": SLP_G_GPD,
		"SLP_G_GMF": SLP_G_GMF,
		"SLP_G_HEF": SLP_G_HEF,
		"SLP_G_HMF": SLP_G_HMF,
		"SLP_G_HKO": SLP_G_HKO,
	}

	_KundengruppeValueToName = map[Kundengruppe]string{
		RLM:       "RLM",
		SLP_S_G0:  "SLP_S_G0",
		SLP_S_G1:  "SLP_S_G1",
		SLP_S_G2:  "SLP_S_G2",
		SLP_S_G3:  "SLP_S_G3",
		SLP_S_G4:  "SLP_S_G4",
		SLP_S_G5:  "SLP_S_G5",
		SLP_S_G6:  "SLP_S_G6",
		SLP_S_G7:  "SLP_S_G7",
		SLP_S_L0:  "SLP_S_L0",
		SLP_S_L1:  "SLP_S_L1",
		SLP_S_L2:  "SLP_S_L2",
		SLP_S_H0:  "SLP_S_H0",
		SLP_S_SB:  "SLP_S_SB",
		SLP_S_HZ:  "SLP_S_HZ",
		SLP_S_WP:  "SLP_S_WP",
		SLP_G_GKO: "SLP_G_GKO",
		SLP_G_GHA: "SLP_G_GHA",
		SLP_G_GMK: "SLP_G_GMK",
		SLP_G_GBD: "SLP_G_GBD",
		SLP_G_GGA: "SLP_G_GGA",
		SLP_G_GBH: "SLP_G_GBH",
		SLP_G_GBA: "SLP_G_GBA",
		SLP_G_GWA: "SLP_G_GWA",
		SLP_G_GGB: "SLP_G_GGB",
		SLP_G_GPD: "SLP_G_GPD",
		SLP_G_GMF: "SLP_G_GMF",
		SLP_G_HEF: "SLP_G_HEF",
		SLP_G_HMF: "SLP_G_HMF",
		SLP_G_HKO: "SLP_G_HKO",
	}
)

func init() {
	var v Kundengruppe
	if _, ok := interface{}(v).(fmt.Stringer); ok {
		_KundengruppeNameToValue = map[string]Kundengruppe{
			interface{}(RLM).(fmt.Stringer).String():       RLM,
			interface{}(SLP_S_G0).(fmt.Stringer).String():  SLP_S_G0,
			interface{}(SLP_S_G1).(fmt.Stringer).String():  SLP_S_G1,
			interface{}(SLP_S_G2).(fmt.Stringer).String():  SLP_S_G2,
			interface{}(SLP_S_G3).(fmt.Stringer).String():  SLP_S_G3,
			interface{}(SLP_S_G4).(fmt.Stringer).String():  SLP_S_G4,
			interface{}(SLP_S_G5).(fmt.Stringer).String():  SLP_S_G5,
			interface{}(SLP_S_G6).(fmt.Stringer).String():  SLP_S_G6,
			interface{}(SLP_S_G7).(fmt.Stringer).String():  SLP_S_G7,
			interface{}(SLP_S_L0).(fmt.Stringer).String():  SLP_S_L0,
			interface{}(SLP_S_L1).(fmt.Stringer).String():  SLP_S_L1,
			interface{}(SLP_S_L2).(fmt.Stringer).String():  SLP_S_L2,
			interface{}(SLP_S_H0).(fmt.Stringer).String():  SLP_S_H0,
			interface{}(SLP_S_SB).(fmt.Stringer).String():  SLP_S_SB,
			interface{}(SLP_S_HZ).(fmt.Stringer).String():  SLP_S_HZ,
			interface{}(SLP_S_WP).(fmt.Stringer).String():  SLP_S_WP,
			interface{}(SLP_G_GKO).(fmt.Stringer).String(): SLP_G_GKO,
			interface{}(SLP_G_GHA).(fmt.Stringer).String(): SLP_G_GHA,
			interface{}(SLP_G_GMK).(fmt.Stringer).String(): SLP_G_GMK,
			interface{}(SLP_G_GBD).(fmt.Stringer).String(): SLP_G_GBD,
			interface{}(SLP_G_GGA).(fmt.Stringer).String(): SLP_G_GGA,
			interface{}(SLP_G_GBH).(fmt.Stringer).String(): SLP_G_GBH,
			interface{}(SLP_G_GBA).(fmt.Stringer).String(): SLP_G_GBA,
			interface{}(SLP_G_GWA).(fmt.Stringer).String(): SLP_G_GWA,
			interface{}(SLP_G_GGB).(fmt.Stringer).String(): SLP_G_GGB,
			interface{}(SLP_G_GPD).(fmt.Stringer).String(): SLP_G_GPD,
			interface{}(SLP_G_GMF).(fmt.Stringer).String(): SLP_G_GMF,
			interface{}(SLP_G_HEF).(fmt.Stringer).String(): SLP_G_HEF,
			interface{}(SLP_G_HMF).(fmt.Stringer).String(): SLP_G_HMF,
			interface{}(SLP_G_HKO).(fmt.Stringer).String(): SLP_G_HKO,
		}
	}
}

// MarshalJSON is generated so Kundengruppe satisfies json.Marshaler.
func (r Kundengruppe) MarshalJSON() ([]byte, error) {
	if s, ok := interface{}(r).(fmt.Stringer); ok {
		return json.Marshal(s.String())
	}
	s, ok := _KundengruppeValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid Kundengruppe: %d", r)
	}
	return json.Marshal(s)
}

// UnmarshalJSON is generated so Kundengruppe satisfies json.Unmarshaler.
func (r *Kundengruppe) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Kundengruppe should be a string, got %s", data)
	}
	v, ok := _KundengruppeNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid Kundengruppe %q", s)
	}
	*r = v
	return nil
}

// Code generated by jsonenums --type Angebotsstatus; DO NOT EDIT.

package angebotsstatus

import (
	"encoding/json"
	"fmt"
)

var (
	_AngebotsstatusNameToValue = map[string]Angebotsstatus{
		"KONZEPTION":    KONZEPTION,
		"UNVERBINDLICH": UNVERBINDLICH,
		"VERBINDLICH":   VERBINDLICH,
		"BEAUFTRAGT":    BEAUFTRAGT,
		"UNGUELTIG":     UNGUELTIG,
		"ABGELEHNT":     ABGELEHNT,
		"NACHGEFASST":   NACHGEFASST,
		"AUSSTEHEND":    AUSSTEHEND,
		"ERLEDIGT":      ERLEDIGT,
	}

	_AngebotsstatusValueToName = map[Angebotsstatus]string{
		KONZEPTION:    "KONZEPTION",
		UNVERBINDLICH: "UNVERBINDLICH",
		VERBINDLICH:   "VERBINDLICH",
		BEAUFTRAGT:    "BEAUFTRAGT",
		UNGUELTIG:     "UNGUELTIG",
		ABGELEHNT:     "ABGELEHNT",
		NACHGEFASST:   "NACHGEFASST",
		AUSSTEHEND:    "AUSSTEHEND",
		ERLEDIGT:      "ERLEDIGT",
	}
)

func init() {
	var v Angebotsstatus
	if _, ok := interface{}(v).(fmt.Stringer); ok {
		_AngebotsstatusNameToValue = map[string]Angebotsstatus{
			interface{}(KONZEPTION).(fmt.Stringer).String():    KONZEPTION,
			interface{}(UNVERBINDLICH).(fmt.Stringer).String(): UNVERBINDLICH,
			interface{}(VERBINDLICH).(fmt.Stringer).String():   VERBINDLICH,
			interface{}(BEAUFTRAGT).(fmt.Stringer).String():    BEAUFTRAGT,
			interface{}(UNGUELTIG).(fmt.Stringer).String():     UNGUELTIG,
			interface{}(ABGELEHNT).(fmt.Stringer).String():     ABGELEHNT,
			interface{}(NACHGEFASST).(fmt.Stringer).String():   NACHGEFASST,
			interface{}(AUSSTEHEND).(fmt.Stringer).String():    AUSSTEHEND,
			interface{}(ERLEDIGT).(fmt.Stringer).String():      ERLEDIGT,
		}
	}
}

// MarshalJSON is generated so Angebotsstatus satisfies json.Marshaler.
func (r Angebotsstatus) MarshalJSON() ([]byte, error) {
	if s, ok := interface{}(r).(fmt.Stringer); ok {
		return json.Marshal(s.String())
	}
	s, ok := _AngebotsstatusValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid Angebotsstatus: %d", r)
	}
	return json.Marshal(s)
}

// UnmarshalJSON is generated so Angebotsstatus satisfies json.Unmarshaler.
func (r *Angebotsstatus) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Angebotsstatus should be a string, got %s", data)
	}
	v, ok := _AngebotsstatusNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid Angebotsstatus %q", s)
	}
	*r = v
	return nil
}

// Code generated by jsonenums --type Rechnungstyp; DO NOT EDIT.

package rechnungstyp

import (
	"encoding/json"
	"fmt"
)

var (
	_RechnungstypNameToValue = map[string]Rechnungstyp{
		"ABSCHLAGSRECHNUNG":          ABSCHLAGSRECHNUNG,
		"TURNUSRECHNUNG":             TURNUSRECHNUNG,
		"MONATSRECHNUNG":             MONATSRECHNUNG,
		"WIMRECHNUNG":                WIMRECHNUNG,
		"ZWISCHENRECHNUNG":           ZWISCHENRECHNUNG,
		"INTEGRIERTE_13TE_RECHNUNG":  INTEGRIERTE_13TE_RECHNUNG,
		"ZUSAETZLICHE_13TE_RECHNUNG": ZUSAETZLICHE_13TE_RECHNUNG,
		"MEHRMINDERMENGENRECHNUNG":   MEHRMINDERMENGENRECHNUNG,
		"ABSCHLUSSRECHNUNG":          ABSCHLUSSRECHNUNG,
		"MSBRECHNUNG":                MSBRECHNUNG,
		"KAPAZITAETSRECHNUNG":        KAPAZITAETSRECHNUNG,
		"SONDERRECHNUNG":             SONDERRECHNUNG,
	}

	_RechnungstypValueToName = map[Rechnungstyp]string{
		ABSCHLAGSRECHNUNG:          "ABSCHLAGSRECHNUNG",
		TURNUSRECHNUNG:             "TURNUSRECHNUNG",
		MONATSRECHNUNG:             "MONATSRECHNUNG",
		WIMRECHNUNG:                "WIMRECHNUNG",
		ZWISCHENRECHNUNG:           "ZWISCHENRECHNUNG",
		INTEGRIERTE_13TE_RECHNUNG:  "INTEGRIERTE_13TE_RECHNUNG",
		ZUSAETZLICHE_13TE_RECHNUNG: "ZUSAETZLICHE_13TE_RECHNUNG",
		MEHRMINDERMENGENRECHNUNG:   "MEHRMINDERMENGENRECHNUNG",
		ABSCHLUSSRECHNUNG:          "ABSCHLUSSRECHNUNG",
		MSBRECHNUNG:                "MSBRECHNUNG",
		KAPAZITAETSRECHNUNG:        "KAPAZITAETSRECHNUNG",
		SONDERRECHNUNG:             "SONDERRECHNUNG",
	}
)

func init() {
	var v Rechnungstyp
	if _, ok := interface{}(v).(fmt.Stringer); ok {
		_RechnungstypNameToValue = map[string]Rechnungstyp{
			interface{}(ABSCHLAGSRECHNUNG).(fmt.Stringer).String():          ABSCHLAGSRECHNUNG,
			interface{}(TURNUSRECHNUNG).(fmt.Stringer).String():             TURNUSRECHNUNG,
			interface{}(MONATSRECHNUNG).(fmt.Stringer).String():             MONATSRECHNUNG,
			interface{}(WIMRECHNUNG).(fmt.Stringer).String():                WIMRECHNUNG,
			interface{}(ZWISCHENRECHNUNG).(fmt.Stringer).String():           ZWISCHENRECHNUNG,
			interface{}(INTEGRIERTE_13TE_RECHNUNG).(fmt.Stringer).String():  INTEGRIERTE_13TE_RECHNUNG,
			interface{}(ZUSAETZLICHE_13TE_RECHNUNG).(fmt.Stringer).String(): ZUSAETZLICHE_13TE_RECHNUNG,
			interface{}(MEHRMINDERMENGENRECHNUNG).(fmt.Stringer).String():   MEHRMINDERMENGENRECHNUNG,
			interface{}(ABSCHLUSSRECHNUNG).(fmt.Stringer).String():          ABSCHLUSSRECHNUNG,
			interface{}(MSBRECHNUNG).(fmt.Stringer).String():                MSBRECHNUNG,
			interface{}(KAPAZITAETSRECHNUNG).(fmt.Stringer).String():        KAPAZITAETSRECHNUNG,
			interface{}(SONDERRECHNUNG).(fmt.Stringer).String():             SONDERRECHNUNG,
		}
	}
}

// MarshalJSON is generated so Rechnungstyp satisfies json.Marshaler.
func (r Rechnungstyp) MarshalJSON() ([]byte, error) {
	if s, ok := interface{}(r).(fmt.Stringer); ok {
		return json.Marshal(s.String())
	}
	s, ok := _RechnungstypValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid Rechnungstyp: %d", r)
	}
	return json.Marshal(s)
}

// UnmarshalJSON is generated so Rechnungstyp satisfies json.Unmarshaler.
func (r *Rechnungstyp) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Rechnungstyp should be a string, got %s", data)
	}
	v, ok := _RechnungstypNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid Rechnungstyp %q", s)
	}
	*r = v
	return nil
}
